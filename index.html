<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>è²ªåƒè›‡éŠæˆ²</title>
  <style>
    :root {
      --bg: #0f172a;
      --card: #111827;
      --grid: #1f2937;
      --snake: #22c55e;
      --snake-head: #16a34a;
      --food: #ef4444;
      --text: #e5e7eb;
      --sub: #94a3b8;
      --accent: #38bdf8;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      min-height: 100vh;
      display: grid;
      place-items: center;
      background: radial-gradient(circle at top, #1e293b, var(--bg));
      color: var(--text);
      font-family: "Noto Sans TC", "Microsoft JhengHei", sans-serif;
      padding: 20px;
    }

    .game-wrap {
      width: min(92vw, 500px);
      background: rgba(17, 24, 39, 0.9);
      border: 1px solid #334155;
      border-radius: 16px;
      padding: 16px;
      box-shadow: 0 20px 40px rgba(0, 0, 0, 0.35);
    }

    h1 {
      margin: 0 0 12px;
      font-size: 1.4rem;
      text-align: center;
    }

    .status {
      display: flex;
      justify-content: space-between;
      gap: 12px;
      margin-bottom: 12px;
      color: var(--sub);
      font-size: 0.95rem;
    }

    .status b { color: var(--text); }

    canvas {
      width: 100%;
      aspect-ratio: 1/1;
      background: var(--card);
      border: 1px solid #334155;
      border-radius: 12px;
      display: block;
      image-rendering: pixelated;
    }

    .controls {
      margin-top: 12px;
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 8px;
      user-select: none;
    }

    .btn {
      border: 1px solid #334155;
      background: #1e293b;
      color: var(--text);
      border-radius: 10px;
      padding: 10px;
      font-size: 1rem;
      text-align: center;
    }

    .btn:active { transform: translateY(1px); }

    .btn.start {
      margin-top: 12px;
      width: 100%;
      background: var(--accent);
      color: #0f172a;
      border: none;
      font-weight: 700;
    }

    .hint {
      margin-top: 10px;
      color: var(--sub);
      text-align: center;
      font-size: 0.85rem;
    }
  </style>
</head>
<body>
  <main class="game-wrap">
    <h1>ğŸ è²ªåƒè›‡</h1>
    <section class="status">
      <div>åˆ†æ•¸ï¼š<b id="score">0</b></div>
      <div>æœ€é«˜åˆ†ï¼š<b id="best">0</b></div>
      <div id="state">æŒ‰é–‹å§‹éŠæˆ²</div>
    </section>

    <canvas id="board" width="400" height="400" aria-label="è²ªåƒè›‡ç•«å¸ƒ"></canvas>

    <div class="controls">
      <button class="btn" data-dir="up">â¬†ï¸</button>
      <button class="btn" id="pause">â¯ æš«åœ</button>
      <button class="btn" data-dir="right">â¡ï¸</button>
      <button class="btn" data-dir="left">â¬…ï¸</button>
      <button class="btn" data-dir="down">â¬‡ï¸</button>
      <button class="btn" id="restart">ğŸ” é‡ä¾†</button>
    </div>

    <button class="btn start" id="start">é–‹å§‹éŠæˆ²</button>
    <p class="hint">ä½¿ç”¨æ–¹å‘éµæˆ–æŒ‰éˆ•æ§åˆ¶ï¼Œåƒåˆ°ç´…è‰²é£Ÿç‰©å°±æœƒè®Šé•·ã€‚</p>
  </main>

  <script>
    const board = document.getElementById('board');
    const ctx = board.getContext('2d');
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const stateEl = document.getElementById('state');

    const gridCount = 20;
    const cell = board.width / gridCount;
    const bestKey = 'snake-best-score';

    let snake;
    let dir;
    let nextDir;
    let food;
    let score;
    let timer;
    let running = false;
    let paused = false;

    function init() {
      snake = [{ x: 10, y: 10 }];
      dir = { x: 1, y: 0 };
      nextDir = { ...dir };
      food = spawnFood();
      score = 0;
      paused = false;
      updateScore();
      draw();
      stateEl.textContent = 'æŒ‰é–‹å§‹éŠæˆ²';
      bestEl.textContent = localStorage.getItem(bestKey) || '0';
    }

    function spawnFood() {
      let pos;
      do {
        pos = {
          x: Math.floor(Math.random() * gridCount),
          y: Math.floor(Math.random() * gridCount),
        };
      } while (snake.some((part) => part.x === pos.x && part.y === pos.y));
      return pos;
    }

    function updateScore() {
      scoreEl.textContent = String(score);
      const best = Number(localStorage.getItem(bestKey) || 0);
      if (score > best) {
        localStorage.setItem(bestKey, String(score));
        bestEl.textContent = String(score);
      }
    }

    function setDirection(newDir) {
      if (!running || paused) return;
      if (newDir.x === -dir.x && newDir.y === -dir.y) return;
      nextDir = newDir;
    }

    function step() {
      dir = nextDir;
      const head = { x: snake[0].x + dir.x, y: snake[0].y + dir.y };

      const hitsWall = head.x < 0 || head.y < 0 || head.x >= gridCount || head.y >= gridCount;
      const hitsSelf = snake.some((part) => part.x === head.x && part.y === head.y);

      if (hitsWall || hitsSelf) {
        gameOver();
        return;
      }

      snake.unshift(head);

      if (head.x === food.x && head.y === food.y) {
        score += 1;
        updateScore();
        food = spawnFood();
      } else {
        snake.pop();
      }

      draw();
    }

    function drawGrid() {
      ctx.strokeStyle = '#1f2937';
      ctx.lineWidth = 1;
      for (let i = 0; i <= gridCount; i++) {
        const p = i * cell;
        ctx.beginPath();
        ctx.moveTo(p, 0);
        ctx.lineTo(p, board.height);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(0, p);
        ctx.lineTo(board.width, p);
        ctx.stroke();
      }
    }

    function draw() {
      ctx.fillStyle = '#111827';
      ctx.fillRect(0, 0, board.width, board.height);
      drawGrid();

      ctx.fillStyle = '#ef4444';
      ctx.beginPath();
      ctx.arc(food.x * cell + cell / 2, food.y * cell + cell / 2, cell * 0.35, 0, Math.PI * 2);
      ctx.fill();

      snake.forEach((part, idx) => {
        ctx.fillStyle = idx === 0 ? '#16a34a' : '#22c55e';
        ctx.fillRect(part.x * cell + 1, part.y * cell + 1, cell - 2, cell - 2);
      });
    }

    function start() {
      if (running) return;
      running = true;
      paused = false;
      stateEl.textContent = 'é€²è¡Œä¸­';
      timer = setInterval(step, 130);
    }

    function togglePause() {
      if (!running) return;
      paused = !paused;
      stateEl.textContent = paused ? 'å·²æš«åœ' : 'é€²è¡Œä¸­';
      if (paused) {
        clearInterval(timer);
      } else {
        timer = setInterval(step, 130);
      }
    }

    function restart() {
      clearInterval(timer);
      running = false;
      init();
    }

    function gameOver() {
      clearInterval(timer);
      running = false;
      stateEl.textContent = 'éŠæˆ²çµæŸ';
      draw();
      ctx.fillStyle = 'rgba(15, 23, 42, 0.65)';
      ctx.fillRect(0, 0, board.width, board.height);
      ctx.fillStyle = '#e5e7eb';
      ctx.font = 'bold 32px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('Game Over', board.width / 2, board.height / 2 - 10);
      ctx.font = '18px sans-serif';
      ctx.fillText(`åˆ†æ•¸ï¼š${score}`, board.width / 2, board.height / 2 + 25);
    }

    document.addEventListener('keydown', (e) => {
      const map = {
        ArrowUp: { x: 0, y: -1 },
        ArrowDown: { x: 0, y: 1 },
        ArrowLeft: { x: -1, y: 0 },
        ArrowRight: { x: 1, y: 0 },
      };
      if (map[e.key]) {
        e.preventDefault();
        setDirection(map[e.key]);
      }
      if (e.key === ' ') {
        e.preventDefault();
        togglePause();
      }
    });

    document.querySelectorAll('[data-dir]').forEach((btn) => {
      btn.addEventListener('click', () => {
        const map = {
          up: { x: 0, y: -1 },
          down: { x: 0, y: 1 },
          left: { x: -1, y: 0 },
          right: { x: 1, y: 0 },
        };
        setDirection(map[btn.dataset.dir]);
      });
    });

    document.getElementById('start').addEventListener('click', start);
    document.getElementById('pause').addEventListener('click', togglePause);
    document.getElementById('restart').addEventListener('click', restart);

    init();
  </script>
</body>
</html>
